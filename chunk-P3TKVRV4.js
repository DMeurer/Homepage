import{a as L,b as W}from"./chunk-FTYQV3CK.js";import{b as A}from"./chunk-LDCH5Z75.js";import{a as j}from"./chunk-RMYJHPME.js";import"./chunk-IEUPSTQ2.js";import{e as O,h as B}from"./chunk-T5ENUITS.js";import{Ab as y,Cb as P,Gb as D,Hb as I,Ib as J,Ja as s,Nb as e,Oa as S,P as C,Va as c,Z as d,_ as u,_a as E,ka as _,lb as M,mb as T,nb as k,ob as m,pb as n,qb as t,rb as i,wb as b}from"./chunk-3BOC6AYW.js";import{g as p}from"./chunk-WR2VUDLS.js";var $=[{tag:"r2d2/two-wheeled-movement",name:"Simulating two wheeled movement",description:"Simulating the movement of a R2D2-like robot",image:"/blog/r2d2/two-wheel-movement/cover.png",date:new Date("2025-07-019"),chips:[{name:"R2D2 - Digital Twin",type:"parent-project"},{name:"Unity",type:"tool"}]}];function V(r,a){if(r&1&&i(0,"app-project-card",3),r&2){let o=a.$implicit;m("project",o)}}var g=class r{BLOG_POSTS=$;static \u0275fac=function(o){return new(o||r)};static \u0275cmp=c({type:r,selectors:[["app-blog"]],decls:7,vars:0,consts:[[1,"page-header"],[2,"margin-bottom","50px"],[1,"card-container"],[3,"project"]],template:function(o,l){o&1&&(n(0,"h1",0),e(1,"Blog Posts"),t(),n(2,"p",1),e(3,"I might post some stuff here, I dont have in my Projects. Just because it was for University or similar."),t(),n(4,"div",2),T(5,V,1,1,"app-project-card",3,M),t()),o&2&&(s(5),k(l.BLOG_POSTS))},dependencies:[j],encapsulation:2})};var w=class r{mathJaxLoaded=!1;loadingPromise=null;constructor(){this.initMathJax()}renderMath(a){return p(this,null,function*(){if(yield this.initMathJax(),this.mathJaxLoaded&&MathJax&&MathJax.typesetPromise)try{yield MathJax.typesetPromise([a])}catch(o){console.error("MathJax rendering error:",o)}})}renderMathContent(a){return p(this,null,function*(){return yield this.initMathJax(),a})}initMathJax(){return this.loadingPromise?this.loadingPromise:(this.loadingPromise=new Promise(a=>{let o=()=>{typeof MathJax<"u"&&MathJax.typesetPromise?(this.mathJaxLoaded=!0,a()):setTimeout(o,100)};o()}),this.loadingPromise)}static \u0275fac=function(o){return new(o||r)};static \u0275prov=C({token:r,factory:r.\u0275fac,providedIn:"root"})};var G=["mathContainer"];function z(r,a){if(r&1){let o=b();n(0,"button",3),y("click",function(){d(o);let h=P();return u(h.copyLatex())}),i(1,"ng-icon",4),t()}}var f=class r{constructor(a){this.mathJaxService=a}content="";enableCopy=!0;mathContainer;showCopyButton=!1;ngAfterViewInit(){this.updateContent()}ngOnChanges(a){a.content&&!a.content.firstChange&&this.updateContent()}onMouseEnter(){this.showCopyButton=!0}onMouseLeave(){this.showCopyButton=!1}copyLatex(){this.content&&navigator.clipboard.writeText(this.content).then(()=>{console.log("LaTeX copied to clipboard")}).catch(a=>{console.error("Failed to copy LaTeX: ",a)})}updateContent(){this.mathContainer&&(this.mathContainer.nativeElement.innerHTML=this.content,this.renderMath())}renderMath(){return p(this,null,function*(){try{yield this.mathJaxService.renderMath(this.mathContainer.nativeElement)}catch(a){console.error("Error rendering math:",a)}})}static \u0275fac=function(o){return new(o||r)(S(w))};static \u0275cmp=c({type:r,selectors:[["app-math-content"]],viewQuery:function(o,l){if(o&1&&D(G,7),o&2){let h;I(h=J())&&(l.mathContainer=h.first)}},inputs:{content:"content",enableCopy:"enableCopy"},features:[_],decls:4,vars:1,consts:[["mathContainer",""],[1,"math-content-wrapper",3,"mouseenter","mouseleave"],["class","copy-button","title","Copy LaTeX",3,"click",4,"ngIf"],["title","Copy LaTeX",1,"copy-button",3,"click"],["name","matContentCopy","size","16"]],template:function(o,l){if(o&1){let h=b();n(0,"div",1),y("mouseenter",function(){return d(h),u(l.onMouseEnter())})("mouseleave",function(){return d(h),u(l.onMouseLeave())}),i(1,"div",null,0),E(3,z,2,0,"button",2),t()}o&2&&(s(3),m("ngIf",l.showCopyButton&&l.enableCopy))},dependencies:[B,O,A],styles:[".math-content-wrapper[_ngcontent-%COMP%]{position:relative;display:block}.copy-button[_ngcontent-%COMP%]{position:absolute;top:4px;right:4px;background:#000000b3;color:#fff;border:none;border-radius:4px;padding:4px 6px;font-size:12px;cursor:pointer;opacity:0;transition:opacity .2s ease-in-out;z-index:10}.math-content-wrapper[_ngcontent-%COMP%]:hover   .copy-button[_ngcontent-%COMP%]{opacity:1}.copy-button[_ngcontent-%COMP%]:hover{background:#000000e6}"]})};var v=class r{formula_angle_known=`
		$$
		\\begin{align}
				\\frac{\\text{l_dist}}{r_l}&=\\alpha\\\\
				\\frac{\\text{r_dist}}{r_r}&=\\alpha\\\\
				|r_l-r_{r}| &= \\text{wheelspacing}\\\\
		\\end{align}
		$$
	`;formula_angle_result=`
		$$
		\\begin{align}
			\\alpha_{rad}&=\\frac{\\text{r_dist}-\\text{l_dist}}{\\text{l_space}+\\text{r_space}}\\\\
			\\alpha_{deg}&=\\frac{\\text{r_dist}-\\text{l_dist}}{\\text{l_space}+\\text{r_space}}*\\frac{360}{2\\pi}
		\\end{align}
		$$
	`;formula_closest_point=`
	$$
	\\vec F_g=\\frac{ \\vec b \\cdot \\vec n_2 - \\vec a \\cdot \\vec n_2 }{ \\vec v \\cdot \\vec n_2 } \\vec v + \\vec a \\quad \\text{ using: } \\quad  \\vec n_2 = \\vec w \\times (\\vec v \\times \\vec w)
	$$
	`;static \u0275fac=function(o){return new(o||r)};static \u0275cmp=c({type:r,selectors:[["app-r2d2-two-wheeled-movement"]],decls:121,vars:4,consts:[[1,"page-header"],["alt","drawing of the three movement types","height","auto","src","/blog/r2d2/two-wheel-movement/simple.svg","width","100%"],["imageAlt","angle calculation","imageHeight","auto","imagePosition","right","imageSrc","/blog/r2d2/two-wheel-movement/geogebra-angle-calc.png","ratio","2img-1text"],["alt","Drawing of how we calculate the angle","height","auto","src","/blog/r2d2/two-wheel-movement/angle-calc.svg","width","100%"],[3,"content"],["imageAlt","Animation of the alternate turning point calculation","imageHeight","auto","imagePosition","left","imageSrc","/blog/r2d2/two-wheel-movement/TurningPointManim.mp4","ratio","2img-1text"],["alt","3D Admination using GeoGebra","height","auto","src","/blog/r2d2/two-wheel-movement/3D-Sequence-manim.webm","width","100%"],["imageAlt","3D closest point calculation","imageBackgroundColor","#f0f0f0","imageHeight","auto","imagePosition","right","imageSrc","/blog/r2d2/two-wheel-movement/wikipedia-closest-points.svg","ratio","2img-1text"],["alt","3D Admination using GeoGebra","height","auto","src","/blog/r2d2/two-wheel-movement/final-capture.webm","width","100%"],[1,"footer-section"]],template:function(o,l){o&1&&(n(0,"h1",0),e(1,"Simulating movement with two wheels"),t(),n(2,"h3"),e(3,"Background information"),t(),n(4,"p"),e(5," In the fourth semester of studying computer science, we had our first project with a team of four developers."),i(6,"br"),e(7," The goal was to create a digital twin of a R2D2 Robot built by other students previously. The main objective was to have programs run on both the real robot and the digital twin. How we achieve this was left for us to figure out."),i(8,"br"),e(9,` We opted for a common communication system where you can later switch connections or possibly even connect to both at once. As a simulation environment we chose the Unity game engine, as it is the most flexible regarding future sensor simulation. It will make everything a bit more complex compared to a available solution, but dependent on a vendors set of sensors, as we don't know what sensors will be used in the future.
`),t(),n(10,"h2"),e(11,"What is available?"),t(),n(12,"p"),e(13," When simulating a robot, it's best to know its size, range of motion, movement speed, etc. This information should be available in the CAD files but there simply were none. Very surprising actually, as the Robot is fully 3D printed."),i(14,"br"),e(15,` Anyways we ended up measuring everything by hand, with an expectable tolerance.
`),t(),n(16,"p"),e(17," The next important information is what information we receive. We chose to send the motor speed as a float between -1 and 1, and only send changes in speed."),i(18,"br"),e(19,` At this point you can probably spot our future problems with detecting a connection loss.
`),t(),n(20,"p"),e(21," Tl;Dr: "),i(22,"br"),e(23,` We have a rough measurement of the robot size and movements, and receive motor speed as "percentage" between -1 and 1.
`),t(),n(24,"h2"),e(25,"Simulating the movement"),t(),n(26,"h3"),e(27,"The simple and naive approach"),t(),n(28,"p"),e(29,` The first draft was a oversimplification on what movements types we might have.
`),t(),i(30,"app-image-wrapper",1),n(31,"p"),e(32,` First we got straight, so both wheels have the same speed. Fairly simple. Just calculate the distance one of the wheels should have travelled, and multiplying it with a normalized forward vector.
`),t(),n(33,"p"),e(34,` Second is spinning, so the wheels are rotating in opposite directions but at the same speed. Also relatively simple. Using the one wheels distance and the distance between the center point and the wheels we can calculate the angle of the circle segment. Once we have these its a matter of calling a rotate method in Unity.
`),t(),n(35,"p"),e(36," The third is turning, when only one wheel is turning. Taking the circle segment calculation from the spin movement, but using the distance of the wheels as radius, we know where to put the robot and how to much to rotate it."),i(37,"br"),e(38,` But to actually move it, we need the new position as vector.
`),t(),n(39,"p"),e(40,` Now this works, but using this, we are limited to exactly these movement types. We are receiving the motor speeds as float, landing at one of these is fairly rare.
`),t(),n(41,"h3"),e(42,"The complex but universal solution"),t(),n(43,"app-image-content-layout",2)(44,"p"),e(45," As this simplification wont cut it, we need something new. Digging deeper into the math behind circle segments, we notice we can calculate the angle just from two path lengths. "),t(),n(46,"p"),e(47," We can use the same formulas as above, we just need to solve for something else. "),t()(),n(48,"p"),e(49,` Ok so now lets look at what we want and what we've got. First of course what we know and can use for the calculation.
`),t(),i(50,"app-image-wrapper",3),n(51,"p"),e(52,` The following are three statements that are true and we can use them to calculate the angle, since we got three unknows and three equations.
`),t(),i(53,"app-math-content",4)(54,"br")(55,"app-math-content",4),n(56,"p"),e(57,` after solving for the angle we get a a result for the angle in radians, and the second one for the angle in degrees. The one with degrees is the one we will use in Unity, as it is the standard there.
`),t(),i(58,"app-math-content",4),n(59,"p"),e(60," This solution will actually tell us the turning point for free, as this can be calculated using a normalized vector from the center of the robot to one wheel and the turn radius of the wheel."),i(61,"br")(62,"br"),e(63,` That's everything we need. We just need to make the vector from the center to the wheel the right length, and add it to a rotated version if itself, and we got a new position. Rotate the robot by the angle we calculated, and we are done.
`),t(),n(64,"p"),e(65," Please keep in mind, this is a simplified version of whats actually happening. Including but not limited to:"),i(66,"br"),e(67," We need the center between the wheels as a center point, and not the robots center. These vectors have to be calculated on every update, as the robot can move and turn."),i(68,"br"),e(69,` We cant take the radius of the wheels as is, we need the radius at the center point, so the average of the wheel turning radius.
`),t(),n(70,"h4"),e(71,"Driving Straight"),t(),n(72,"p"),e(73," Now we have a correct and advanced solution. Every movement with any wheel speeds can be calculated. Except for one common edge case."),i(74,"br"),e(75," Bot wheels turning at the same speed, aka. driving straight."),i(76,"br"),e(77,` When we use the formula the angle will be zero and the radius will be infinite. Not very helpful information.
`),t(),n(78,"p"),e(79,` To solve this we have implemented an alternate way of calculating the turning point.
`),t(),n(80,"app-image-content-layout",5)(81,"p"),e(82," By just pretending the wheels drive straight and individually we can draw two lines between the wheels, one in the new and on in the old position."),i(83,"br"),e(84," The intersection of these two lines is the new turning point. Additionally we can easily check if the robot is driving straight, as the lines must be parallel for this. "),t()(),n(85,"h4"),e(86,"A whole dimension of new problems"),t(),n(87,"p"),e(88," Looking good so far, right? Well, for sanity reasons our thoughts and plans made in 2D, as it will drive and not fly. Sadly in reality the robot absolutely can "),n(89,"s"),e(90,"fly"),t(),e(91," fall over. Or in less brutal cases, tilt."),i(92,"br"),e(93,` We have to account for this, as the robot should not drive into the ground when presented with a slope.
`),t(),n(94,"p"),e(95," First things first, we need some directions we can trust. Therefore we created an up vector, bound to the robot. Anything we rotate must now rotate around the up vector."),i(96,"br"),e(97,` Adding the vectors will then look like this:
`),t(),i(98,"app-image-wrapper",6),n(99,"p"),e(100,' The yellow dotted line is the up vector, the black vectors are "center to turning point" and the rotated "center to turning point".'),i(101,"br"),e(102,` (and sorry for the quality, GeoGebra is not the best for this, but this is what we used during development)
`),t(),n(103,"p"),e(104," But apart from making every calculation a bit more complicated, this also introduces a new problem."),i(105,"br"),e(106,` Remember we use intersecting lines to calculate the turning point? Yeah we cant do that anymore.
`),t(),n(107,"app-image-content-layout",7)(108,"p"),e(109," Because of float imprecision, the lines will likely never intersect. So we need to find the points on the lines that are closest to each other. Thankfully, since this something you learn in school, there are plenty of resources online, including a whole dedicated Wikipedia article including ready to steal algorithms for this. "),t(),i(110,"app-math-content",4),t(),n(111,"h2"),e(112,"Implementation"),t(),n(113,"p"),e(114," I wont go into too much detail on this, as it was fairly straightforward to translate the math into code. (At least after you understand Unity's Quaternion system)"),i(115,"br"),e(116,` So, have a look at the result:
`),t(),i(117,"app-image-wrapper",8),n(118,"div",9)(119,"p"),e(120,"Cheers!"),t()()),o&2&&(s(53),m("content","We are looking for $r_r$, $r_l$ and $\\alpha$."),s(2),m("content",l.formula_angle_known),s(3),m("content",l.formula_angle_result),s(52),m("content",l.formula_closest_point))},dependencies:[L,W,f],encapsulation:2})};var ce=[{pathMatch:"full",path:"",component:g},{path:"r2d2/two-wheeled-movement",component:v}];export{ce as routes};
